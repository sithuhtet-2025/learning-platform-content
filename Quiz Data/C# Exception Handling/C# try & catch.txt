INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'In a C# exception handling structure, what is the specific architectural role of the `try` block?', 'To define a global scope for variables.', 'To execute cleanup code unconditionally.', 'To enclose a section of code that might potentially throw an exception during execution.', 'To catch and suppress all runtime errors automatically.', 'C', 'The `try` block serves as a protected region. It encloses code that is at risk of generating a runtime error (an exception), instructing the Common Language Runtime (CLR) to monitor its execution and route any failures to an appropriate `catch` block.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'If you declare and initialize a variable directly inside a `try` block (e.g., `try { string data = ReadFile(); }`), where can that variable be accessed?', 'Anywhere within the containing method.', 'Strictly only within the `try` block.', 'Within both the `try` and `catch` blocks.', 'Within the `try`, `catch`, and `finally` blocks.', 'B', 'Variables declared inside a `try` block are strictly block-scoped. They cease to exist immediately outside the closing brace of the `try` block and cannot be accessed by the corresponding `catch` or `finally` blocks. If you need a variable in multiple blocks, it must be declared before the `try` statement.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'What is the behavior of a parameterless `catch` block (i.e., `catch { ... }`) in C#?', 'It catches only exceptions of type `System.SystemException`.', 'It catches any and all exceptions thrown in the `try` block, but does not provide a variable to access the exception details.', 'It represents a syntax error in modern C#.', 'It ignores the exception and automatically restarts the `try` block.', 'B', 'A general `catch` block without parameters catches absolutely every exception that occurs. While syntactically valid, it provides no information about the error (no message, no stack trace) and is generally considered a dangerous anti-pattern known as "exception swallowing."');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'When you write `catch (SqlException ex)`, what exactly does the `ex` variable represent?', 'A boolean flag indicating if the database is online.', 'A string containing the raw error message.', 'An object reference encapsulating detailed metadata about the specific runtime error, such as the stack trace and error message.', 'A keyword used to re-throw the error to the operating system.', 'C', 'The variable `ex` is a strictly typed object instance of the caught exception class. It encapsulates critical debugging data provided by the CLR, including the `Message`, `StackTrace`, and potentially an `InnerException` that caused the failure.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'What happens if an exception is thrown inside a `try` block, but none of the attached `catch` blocks match the exception''s specific type?', 'The `try` block automatically suppresses the error and continues execution.', 'The compiler throws a syntax error during the build process.', 'The exception propagates (bubbles up) the call stack, searching for a matching `catch` block in the calling methods.', 'The application instantly crashes without searching the call stack.', 'C', 'If a local `catch` block cannot handle the specific type of exception thrown, the CLR immediately propagates the exception up the call stack to the method that invoked the current one. It continues this search until it finds a suitable handler or, if none is found, crashes the application.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'When chaining multiple `catch` blocks after a single `try` block, what critical ordering rule must be strictly followed?', 'Alphabetical order based on the exception class name.', 'From the most general, base exception type down to the most specific.', 'From the most derived, specific exception type down to the most general base type (like `System.Exception`).', 'The order is irrelevant; the CLR evaluates them all simultaneously.', 'C', 'Catch blocks must be ordered from most specific to least specific. The CLR evaluates them top-to-bottom and stops at the first match. If a general `Exception` catch block is placed at the top, it intercepts everything, rendering the specific blocks below it unreachable and causing a compiler error.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'Introduced in C# 6.0, how does applying the `when` keyword to a `catch` block (e.g., `catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)`) alter its behavior?', 'It delays the execution of the catch block by a specified timeframe.', 'It forces the catch block to execute asynchronously on a new thread.', 'It creates an exception filter, meaning the catch block will only intercept the exception if the boolean condition evaluates to true.', 'It automatically logs the exception to the Windows Event Viewer before executing.', 'C', 'Exception filters allow a `catch` block to selectively handle an exception based on its properties, not just its type. If the `when` condition evaluates to false, the catch block is bypassed entirely, and the exception continues bubbling up the stack without being caught and re-thrown.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# try & catch', 'Why is it considered a major architectural anti-pattern to use `try-catch` blocks to direct normal program control flow (e.g., catching a format exception instead of using `int.TryParse`)?', 'Because `try-catch` blocks cannot handle format conversions.', 'Because `catch` blocks are limited to a maximum of three per `try` statement.', 'Because throwing and catching exceptions is a highly expensive operation for the CPU and memory, significantly degrading application performance.', 'Because the compiler automatically removes `try-catch` blocks in Release builds.', 'C', 'Exceptions should be strictly reserved for exceptional, unpredictable failures. The process of generating an exception object, building the stack trace, and unwinding the call stack is computationally heavy. Using patterns like `TryParse` avoids this severe performance penalty during expected control flow scenarios.');