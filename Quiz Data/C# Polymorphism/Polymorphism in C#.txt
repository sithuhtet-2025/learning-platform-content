INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'What is the core concept of Polymorphism in object-oriented programming?', 'The ability of different objects to respond to the same method call in their own specific way.', 'The ability to hide the internal data of an object.', 'The ability to inherit from multiple classes simultaneously.', 'The ability to restrict object instantiation.', 'A', 'Polymorphism (meaning "many forms") allows objects of different classes to be treated as objects of a common base class or interface, responding uniquely to the same method invocation based on their specific derived type.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'Which of the following is a classic example of compile-time (static) polymorphism in C#?', 'Method Overriding', 'Method Overloading', 'Interface Implementation', 'Boxing and Unboxing', 'B', 'Method overloading is resolved by the compiler at compile-time based on the method signature (number and type of parameters passed), making it a form of static polymorphism.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'If a base class reference variable holds a derived class object, and a virtual method is called on that reference, which version of the method is executed?', 'The base class version.', 'The derived class version.', 'A runtime exception is thrown.', 'Both versions are executed sequentially.', 'B', 'This is the essence of runtime (dynamic) polymorphism. The Common Language Runtime (CLR) inspects the actual underlying object type in memory, not the reference type, and executes the derived class''s overridden method.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'Which two keywords are strictly required to implement runtime (dynamic) polymorphism through method overriding in C#?', 'abstract and new', 'static and virtual', 'virtual (or abstract) and override', 'base and derived', 'C', 'To achieve dynamic polymorphism, the parent class method must be marked as ''virtual'' (or ''abstract''), and the child class must explicitly replace it using the ''override'' keyword.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'In the context of polymorphism, what happens when you use the ''new'' keyword instead of ''override'' on a method in a derived class?', 'It perfectly overrides the base method for polymorphic calls.', 'It hides the base method. If called through a base class reference, the base class implementation is executed instead of the derived one.', 'It deletes the base class method from memory.', 'It prevents any further classes from inheriting the method.', 'B', 'The ''new'' keyword intentionally breaks the polymorphic chain (method hiding/shadowing). If a derived object is accessed via a base class reference, the CLR will call the base class''s method, ignoring the derived class''s ''new'' method.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'How are interfaces utilized to achieve polymorphism in C#?', 'By allowing a single class to inherit from multiple base classes.', 'By allowing variables of an interface type to reference any object that implements that interface, dynamically calling the object''s specific implementation.', 'By providing default static methods that all classes must share.', 'Interfaces cannot be used for polymorphism; only abstract classes can.', 'B', 'Interfaces are a powerful mechanism for polymorphism. You can create a collection of an interface type (e.g., List<IShape>) containing completely different objects (Circle, Square) and call the interface''s methods on them seamlessly.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'When iterating through a polymorphic collection (e.g., `List<Animal>`), which operators are safely used to check the underlying runtime type of an object and cast it?', 'typeof and GetType', 'is and as', 'cast and convert', 'try and catch', 'B', 'The ''is'' operator safely checks if an object is compatible with a given type, while the ''as'' operator attempts to cast the object to a specific type (returning null if the cast fails). Both are essential for working with polymorphic collections without throwing exceptions.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Polymorphism in C#', 'Why are abstract classes heavily associated with achieving structural polymorphism?', 'They can be instantiated directly to test different implementations.', 'They force derived classes to provide specific implementations for abstract methods, ensuring a consistent, guaranteed contract for polymorphic method calls.', 'They automatically override all methods in the .NET framework.', 'They prevent developers from using the ''override'' keyword.', 'B', 'Abstract classes define a strict template. By declaring abstract methods, they guarantee that any concrete subclass will have its own implementation of those methods, making it perfectly safe to call them polymorphically through a base class reference.');