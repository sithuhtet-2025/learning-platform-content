INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'In which core Java class are the methods ''wait()'', ''notify()'', and ''notifyAll()'' defined?', 'java.lang.Thread', 'java.lang.Object', 'java.util.concurrent.Executors', 'java.lang.Runnable', 'B', 'Because inter-thread communication utilizes monitor locks associated with objects, the ''wait()'', ''notify()'', and ''notifyAll()'' methods are declared in ''java.lang.Object'' so they are available to every object in the JVM.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'What strict prerequisite must a thread meet before it can successfully invoke ''obj.wait()'' or ''obj.notify()''?', 'The thread must be in the RUNNABLE state.', 'The thread must have a maximum priority level.', 'The thread must currently own the intrinsic monitor lock of the object ''obj'' (i.e., be inside a synchronized block or method for that object).', 'The thread must implement the Callable interface.', 'C', 'Calling ''wait()'' or ''notify()'' requires ownership of the object''s monitor. If a thread attempts to call these methods without holding the synchronized lock on that specific object, the JVM throws an ''IllegalMonitorStateException''.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'When a thread successfully executes ''wait()'' inside a synchronized block, what immediately happens to the lock it is holding?', 'It retains the lock but pauses execution.', 'It releases the lock completely, allowing other threads to acquire it.', 'It temporarily delegates the lock to the main thread.', 'The lock is destroyed and must be recreated.', 'B', 'The ''wait()'' method causes the current thread to pause execution (entering the WAITING state) and explicitly releases the monitor lock it holds on that object, allowing other blocked threads to enter the synchronized block.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'Why is it considered a mandatory best practice to always invoke ''wait()'' inside a ''while'' loop that checks the condition, rather than a simple ''if'' statement?', 'To prevent the thread from ever waking up.', 'To handle "spurious wakeups" where a thread might wake up from waiting without ''notify()'' being called, ensuring the condition is genuinely met before proceeding.', 'Because ''wait()'' only works with iterative loops.', 'To increase the execution speed of the thread scheduler.', 'B', 'The JVM specification warns of "spurious wakeups" where threads can wake from a WAITING state without a notification. A ''while'' loop forces the thread to re-check the logical condition upon waking; if the condition is still false, it safely calls ''wait()'' again.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'What is the exact behavioral difference between ''notify()'' and ''notifyAll()''?', '''notify()'' wakes up the thread that has been waiting the longest, while ''notifyAll()'' wakes up the newest thread.', '''notify()'' wakes up one arbitrarily chosen thread waiting on the object''s monitor, while ''notifyAll()'' wakes up all threads waiting on that monitor.', '''notify()'' is used for static methods, and ''notifyAll()'' is used for instance methods.', 'There is no difference; they are aliases.', 'B', 'The ''notify()'' method signals a single, scheduler-chosen thread to wake up from the wait set. ''notifyAll()'' signals every thread in the wait set, moving them to the BLOCKED state to compete for the monitor lock once the notifying thread releases it.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Inter-thread Communication in Java', 'In a classic Producer-Consumer architecture using wait/notify, what happens if a Consumer calls ''notify()'' but the Producer is currently busy and not in a ''wait()'' state?', 'The notification is queued and delivered when the Producer eventually calls ''wait()''.', 'An IllegalStateException is thrown.', 'The notification is permanently lost.', 'The Consumer thread crashes.', 'C', 'Unlike Semaphores or BlockingQueues which maintain state, standard wait/notify signals are not buffered. If ''notify()'' is called and no thread is currently waiting on that object''s monitor, the signal is entirely lost.');
