INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Java Program to Find the Minimum Number of Operations Required to Reach N Steps', 'In an algorithm designed to find the minimum number of operations to reach N steps from 0 (where allowed operations are "add 1" or "multiply by 2"), what is the optimal greedy choice if the current step N is an even number greater than 0?', 'Subtract 1 from N.', 'Divide N by 2.', 'Multiply N by 2.', 'Add 1 to N.', 'B', 'Working backwards from N to 0: if N is even, dividing by 2 represents the reverse of the "multiply by 2" operation. This greedy choice guarantees the minimum number of steps compared to subtracting 1 multiple times.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Java Program to Find the Minimum Number of Operations Required to Reach N Steps', 'When solving the "Climbing Stairs" variant (finding the number of distinct ways to reach step N by taking 1 or 2 steps at a time), which core algorithmic paradigm is most efficient?', 'Breadth-First Search (BFS)', 'Dynamic Programming', 'Dijkstra''s Algorithm', 'Backtracking', 'B', 'This problem exhibits overlapping subproblems and optimal substructure. Dynamic programming (or memoization) allows the algorithm to store the results of previous step counts (e.g., dp[i] = dp[i-1] + dp[i-2]) to compute the answer in O(N) time, avoiding the exponential O(2^N) time of naive recursion.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Java Program to Find the Minimum Number of Operations Required to Reach N Steps', 'If a purely recursive approach (without memoization) is used to find the number of ways to reach N steps (taking 1 or 2 steps), what is the time complexity?', 'O(1)', 'O(N)', 'O(N log N)', 'O(2^N)', 'D', 'A naive recursive approach recalculates the same subproblems repeatedly, creating a binary recursion tree of depth N. This results in an exponential time complexity of O(2^N).');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Java Program to Find the Minimum Number of Operations Required to Reach N Steps', 'How can you optimize the space complexity of a Dynamic Programming solution for the "Climbing Stairs" problem to O(1) in Java?', 'By using a HashMap to store all previously computed states.', 'By replacing the DP array with two integer variables tracking just the previous two calculated states.', 'By using an ArrayList instead of a primitive array.', 'By increasing the JVM heap size.', 'B', 'Since computing the current step only requires the results of the immediately preceding two steps (i-1 and i-2), you can discard older data and use two scalar variables instead of allocating an O(N) array.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Java Program to Find the Minimum Number of Operations Required to Reach N Steps', 'Consider a greedy algorithm working backwards from N to 0, using operations "divide by 2" (if even) and "subtract 1" (if odd). What is the worst-case time complexity of this Java implementation?', 'O(N)', 'O(log N)', 'O(N^2)', 'O(1)', 'B', 'Because the algorithm aggressively halves the number N whenever it is even, the number of operations scales logarithmically with the size of N, resulting in O(log N) time complexity.');
