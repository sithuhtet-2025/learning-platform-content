INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'What is the primary architectural purpose of thread synchronization in C#?', 'To execute multiple applications simultaneously on the CPU.', 'To prevent race conditions and data corruption by safely coordinating concurrent thread access to shared memory resources.', 'To synchronize application data with a remote cloud database.', 'To automatically restart failed background threads.', 'B', 'When multiple threads read and write to the same memory location simultaneously, data corruption occurs (race conditions). Synchronization mechanisms (like locks) act as traffic lights, ensuring only one thread can access the critical section at a time.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'What does the C# `lock` keyword actually compile down to behind the scenes?', 'A `while(true)` spin-wait loop.', 'A low-level operating system `Mutex`.', 'A `try-finally` block utilizing `Monitor.Enter()` and `Monitor.Exit()`.', 'An asynchronous `await Task.Delay()`.', 'C', 'The `lock` keyword is syntactic sugar. The C# compiler translates it into a robust `try-finally` block using the `System.Threading.Monitor` class. The `Monitor.Enter` method acquires the exclusive lock, and `Monitor.Exit` in the `finally` block guarantees the lock is safely released even if an exception occurs.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'What specific data type restriction is enforced by the C# compiler when choosing an object to `lock` on (e.g., `lock(myObject)`)?', 'It must be a boolean.', 'It must be a primitive value type (like an `int` or `struct`).', 'It must be a reference type (an object instantiated on the heap).', 'It must be a static string.', 'C', 'The `lock` statement explicitly requires a reference type. It relies on the hidden "SyncBlockIndex" present in the object header of every heap-allocated reference type in .NET to track which thread currently owns the lock. Value types (structs) do not possess this metadata header.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'From a software architecture perspective, why is it considered a severe security and stability anti-pattern to `lock` on public objects, `this`, or `typeof(MyClass)`?', 'Because it causes a massive memory leak in the Garbage Collector.', 'Because these objects are visible to external code; another unrelated part of the application could accidentally acquire a lock on the exact same object, instantly causing an application-wide deadlock.', 'Because the CLR automatically deletes public objects when locked.', 'Because they force the thread to execute asynchronously.', 'B', 'Best practice dictates locking strictly on a `private readonly object _lockObj = new object();`. If you lock on `this` or a `Type` object, any external caller with access to your class can lock that same instance, creating hidden, impossible-to-debug deadlocks.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'What defines a "deadlock" scenario in multithreaded programming?', 'A thread that has successfully finished its execution and died.', 'A situation where two or more threads are permanently blocked and frozen, each waiting to acquire a lock that is currently held by the other.', 'A thread that consumes 100% of the CPU in an infinite loop.', 'A thread that is forcefully terminated using `Thread.Abort()`.', 'B', 'A deadlock is a catastrophic concurrency failure. If Thread A locks Resource 1 and waits for Resource 2, while Thread B locks Resource 2 and waits for Resource 1, neither can proceed. They freeze infinitely in a deadly embrace.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'If you only need to safely increment a shared integer counter across multiple threads, which highly optimized class should you use instead of a heavy `lock` statement?', 'System.Threading.Interlocked', 'System.Threading.Mutex', 'System.Threading.Semaphore', 'System.Threading.Volatile', 'A', 'The `Interlocked` class provides atomic operations (like `Interlocked.Increment(ref counter)`). Instead of putting the thread to sleep with a heavy software lock, it uses highly optimized, low-level CPU instructions to safely mutate the number in a single, uninterrupted processor tick.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'What is the primary architectural distinction between a `Monitor` (used by the `lock` keyword) and a `Mutex`?', 'A `Monitor` is for background threads, while a `Mutex` is for the UI thread.', 'A `Monitor` is lightweight and works strictly within a single application process, whereas a `Mutex` is an OS-level construct that can synchronize threads across completely different, independent application processes.', 'A `Monitor` is asynchronous, while a `Mutex` is synchronous.', 'There is no difference; they are interchangeable aliases.', 'B', 'If you need to ensure that only one instance of an application can run on a machine at a time, you use a named `Mutex`. It relies on the operating system kernel, making it much heavier and slower than a `Monitor`, but it cleanly transcends process boundaries.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Synchronization', 'Which synchronization primitive is specifically designed to throttle concurrency by allowing a specified maximum number of threads to access a critical resource simultaneously, blocking any additional threads until one leaves?', 'Monitor', 'EventWaitHandle', 'Semaphore (or SemaphoreSlim)', 'SpinLock', 'C', 'Unlike a `lock` or `Mutex` which act as a strict 1-at-a-time gate (mutual exclusion), a `Semaphore` acts like a bouncer at a club with a capacity limit. It allows N threads to enter concurrently, making it the perfect architectural tool for throttling resource usage (like limiting concurrent database connections).');