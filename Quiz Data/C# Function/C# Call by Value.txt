INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'In C#, what is the default parameter passing mechanism for both value types and reference types if no special modifiers are used?', 'Call by Reference', 'Call by Pointer', 'Call by Value', 'Call by Output', 'C', 'Unless explicitly specified with keywords like `ref`, `out`, or `in`, all arguments in C#—whether they are value types (structs) or reference types (classes)—are passed strictly by value by default.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'What happens in memory when a value type (such as an `int` or a custom `struct`) is passed to a method by value?', 'The method receives a pointer to the original memory address.', 'The method shares the exact same memory space as the caller.', 'A completely new, independent copy of the data is allocated on the stack for the method to use.', 'The data is temporarily moved to the managed heap.', 'C', 'When passing a value type by value, the C# runtime creates a bit-by-bit duplicate of the entire payload on the stack. The called method operates entirely on this local copy.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'If you pass an integer variable `x = 10` to a method by value, and that method changes its local parameter to `20`, what is the value of `x` in the calling code after the method returns?', '10', '20', '0', 'A runtime exception is thrown.', 'A', 'Because the method operates on a completely independent copy of the value type, any modifications made inside the method are immediately discarded when the method exits, leaving the original variable `x` completely untouched at `10`.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'What exactly is copied when you pass a reference type (like an instance of a `class`) to a method by value?', 'A complete, deep clone of the entire object in memory.', 'A shallow copy of the object''s primitive fields.', 'A copy of the memory address (the reference/pointer) that points to the original object on the heap.', 'Nothing is copied; the compiler blocks this operation.', 'C', 'Passing a reference type by value does NOT copy the massive object payload on the heap. Instead, it creates a new copy of the reference pointer itself. Both the original pointer and the newly copied pointer now point to the exact same object in memory.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'If a class instance (reference type) is passed by value, and the called method changes a property of that object (e.g., `customer.Name = "Alice"`), what happens?', 'The original object is unaffected because the method operates on a clone.', 'The original object''s property is updated because both the caller and the method hold references to the exact same underlying object in memory.', 'The compiler throws an error preventing modification of call-by-value reference types.', 'The change only persists until the garbage collector runs.', 'B', 'Because the copied reference still points to the exact same memory address as the original reference, any mutations made to the object''s internal state (its properties or fields) are globally visible to the calling code.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'What happens if a method receives a reference type by value, and inside the method, the parameter is reassigned to a completely `new` object?', 'The original variable in the calling code is also updated to point to the new object.', 'The new object replaces the old object in the exact same memory location.', 'The original variable in the calling code remains completely unchanged, still pointing to the original object.', 'A MemoryLeakException is thrown.', 'C', 'Because the reference itself was passed by value (a copy of the pointer), reassigning the parameter to a `new` object merely updates the method''s local copy of the pointer. The caller''s original pointer remains securely locked onto the original object.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'Which C# data type represents an immutable reference type that, despite behaving like a value type in equality comparisons, is still technically passed by value as a reference copy?', 'int', 'struct', 'enum', 'string', 'D', 'The `string` type is an immutable reference type. When passed by value, a copy of the reference is passed. Because strings cannot be mutated, any perceived modification creates a completely new string object and reassigns the local pointer, leaving the caller''s original string perfectly intact.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Call by Value', 'Why might passing a very large custom `struct` to a method by value introduce performance concerns in a high-frequency loop?', 'Structs require heavy garbage collection overhead when passed by value.', 'Structs are automatically boxed into objects when passed by value.', 'The entire memory footprint of the struct must be physically copied bit-by-bit onto the stack for every single method call.', 'Structs lock the thread they are executing on when passed by value.', 'C', 'Value types are copied entirely when passed by value. If a struct contains dozens of fields and takes up 64 bytes or more, copying that payload repetitively in a tight loop wastes CPU cycles and stack space. This is why the `in` modifier or `ref` are sometimes used for large structs to pass them by reference safely.');