INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'What is the strictly correct C# syntax to define a destructor (also known as a finalizer) for a class named `DatabaseConnection`?', 'public ~DatabaseConnection() { }', 'protected void Destruct() { }', '~DatabaseConnection() { }', 'override Finalize() { }', 'C', 'In C#, a destructor is declared using a tilde (~) immediately followed by the exact name of the class. It structurally resembles a parameterless constructor but is exclusively used for teardown operations.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'Behind the scenes, what does the C# compiler automatically translate a destructor (e.g., `~MyClass()`) into during compilation to Intermediate Language (IL)?', 'A static method that deletes the object from RAM.', 'An override of the `System.Object.Finalize()` method wrapped in a `try-finally` block to ensure the base class finalizer is always called.', 'An implementation of the `IDisposable` interface.', 'A background thread that monitors the object''s state.', 'B', 'The C# destructor syntax is purely syntactic sugar. The compiler automatically rewrites it as an override of the virtual `Object.Finalize()` method, safely injecting `base.Finalize()` into a `finally` block to guarantee the entire inheritance chain is cleaned up.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'Which of the following strict structural rules applies to defining destructors in C#?', 'They can only be defined in static classes.', 'They must be marked with the `public` access modifier.', 'They can be overloaded to accept different parameters.', 'They cannot possess any access modifiers (like `public` or `private`), and they strictly cannot accept any parameters.', 'D', 'Because destructors are invoked automatically by the Garbage Collector (and never by developer code), access modifiers are completely meaningless. Similarly, because no developer explicitly calls them, it is mathematically impossible to pass arguments to them.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'When exactly is a destructor executed in a C# application?', 'Immediately when the `delete` keyword is used on the object.', 'The exact millisecond the object''s variable goes out of scope.', 'Non-deterministically, at some unpredictable time in the future when the Garbage Collector decides to reclaim the object''s memory.', 'When the application is explicitly closed by the user.', 'C', 'Unlike C++, C# uses non-deterministic memory management. You cannot control exactly when an object is destroyed. The Garbage Collector runs on a background thread and fires the destructor only when it eventually decides to process that specific object.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'Can a developer explicitly invoke a destructor from their application code (e.g., `myConnection.~DatabaseConnection();`) to forcefully free memory immediately?', 'Yes, but only if the code is running in an `unsafe` block.', 'Yes, this is the standard way to delete objects in C#.', 'No, destructors can strictly only be invoked by the .NET Garbage Collector.', 'Yes, but it throws a compiler warning.', 'C', 'Developer code is physically prohibited from calling a destructor. It is an internal architectural hook reserved exclusively for the Common Language Runtime''s Garbage Collector.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'From a memory architecture perspective, why does implementing a destructor impose a severe performance penalty on an object?', 'It forces the object to be stored on the execution stack rather than the heap.', 'It requires the object to be continuously tracked by a dedicated background thread.', 'It forces the object into the Finalization Queue. When the GC runs, it cannot immediately delete the object; it must promote it to an older generation and wait for a separate Finalizer thread to execute the destructor first.', 'It locks the entire Garbage Collector while the object exists.', 'C', 'Objects with destructors survive their first Garbage Collection pass because they must be placed in the F-reachable queue for the Finalizer thread to process them. This artificially extends their lifespan in memory, promoting them to Generation 1 or 2, which are collected much less frequently and heavily degrade application performance.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'According to modern .NET architectural guidelines, when is the ONLY appropriate time a developer should explicitly implement a destructor in a class?', 'When the class contains large managed collections (like `List<string>`).', 'When the class directly encapsulates unmanaged operating system resources (like raw file handles, native network sockets, or COM objects).', 'When the class inherits from an interface.', 'When the application requires strict, real-time memory management.', 'B', 'Destructors are safety nets. Managed objects (like Lists or Strings) are handled perfectly by the GC. You only need a destructor if your class talks directly to the OS (unmanaged resources), acting as an absolute last resort to release those native locks if the developer forgets to call `Dispose()`.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('Destructor in C#', 'If a class implements a destructor to clean up unmanaged resources, which structural design pattern MUST it also implement to allow developers to clean up deterministically?', 'The Singleton Pattern', 'The Factory Pattern', 'The IDisposable interface (the Dispose Pattern)', 'The ICloneable interface', 'C', 'If a class holds unmanaged resources, relying solely on the non-deterministic destructor is dangerous because the file or socket might remain locked for hours waiting for the GC. You must implement `IDisposable` so developers can call `.Dispose()` (or use a `using` block) to release the locks immediately and deterministically.');