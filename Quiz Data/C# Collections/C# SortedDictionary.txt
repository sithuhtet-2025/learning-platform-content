INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'How is the SortedDictionary<TKey, TValue> class internally implemented in the .NET framework, and what is its standard time complexity for insertions?', 'As a pair of sorted arrays; O(n) insertion.', 'As a hash table; O(1) insertion.', 'As a binary search tree (Red-Black tree); O(log n) insertion.', 'As a doubly linked list; O(1) insertion.', 'C', 'SortedDictionary is implemented using a binary search tree, specifically a Red-Black tree. This guarantees O(log n) time complexity for insertion, deletion, and retrieval, dynamically maintaining order as elements are manipulated.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'What is the primary difference in performance characteristics between SortedDictionary<TKey, TValue> and SortedList<TKey, TValue>?', 'SortedDictionary uses less memory than SortedList.', 'SortedDictionary has faster O(log n) insertions/removals, while SortedList has slower O(n) insertions/removals but uses less memory.', 'SortedList retrieves elements in O(1) time, while SortedDictionary takes O(log n).', 'SortedDictionary sorts by value, whereas SortedList sorts by key.', 'B', 'SortedList is backed by arrays, making insertions/removals O(n) due to array shifting, but it is memory efficient. SortedDictionary is a tree structure, making insertions/removals faster at O(log n), but each node object requires higher memory overhead.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'What is strictly required for a custom object to be used as a key in a SortedDictionary<TKey, TValue> without throwing an exception at runtime?', 'The key type must override GetHashCode() and Equals().', 'The key type must implement IComparable<T>, or an IComparer<T> must be passed to the constructor.', 'The key type must be a primitive value type (e.g., int, string).', 'The key type must implement IEnumerable<T>.', 'B', 'Because the dictionary must continuously keep elements sorted, it relies on IComparable<T> or a custom IComparer<T> to mathematically determine the relative order of the keys. Hash collections rely on GetHashCode(), but tree structures strictly rely on comparisons.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'When you iterate over a SortedDictionary<TKey, TValue> using a foreach loop, in what order are the elements returned?', 'In the exact chronological order they were inserted.', 'Sorted by the values in ascending order.', 'Sorted by the keys according to the provided or default IComparer<T>.', 'In a completely random, undefined order based on memory allocation.', 'C', 'The defining feature of a SortedDictionary is that enumerating it always yields the KeyValuePair<TKey, TValue> elements strictly sorted by the Key property, ascending by default.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'What happens if you attempt to access an element using a key that does not exist in a SortedDictionary<TKey, TValue> via the indexer (e.g., var val = myDict["Missing"];)?', 'It returns null or the default value for the type.', 'It automatically creates a new node with that key and a default value.', 'It throws a KeyNotFoundException.', 'It returns the closest matching key based on string comparison.', 'C', 'Like the standard generic Dictionary, the indexer getter on a SortedDictionary strictly throws a KeyNotFoundException if the key is not present. Developers should use the TryGetValue() method for safe retrieval without exceptions.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'Why might a developer choose a standard Dictionary<TKey, TValue> over a SortedDictionary<TKey, TValue> if strict sorting is not required?', 'SortedDictionary cannot store reference types as values.', 'Standard Dictionary offers faster O(1) lookups and less memory allocation per element than the tree-based SortedDictionary.', 'SortedDictionary is not type-safe and requires casting.', 'Standard Dictionary automatically trims its excess capacity, whereas SortedDictionary does not.', 'B', 'A standard hash-based Dictionary provides near O(1) time complexity for operations and allocates data in dense arrays. SortedDictionary provides slower O(log n) access and requires allocating a separate heap object (node) for every single entry, increasing GC pressure.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'Which method allows you to safely attempt to add a key/value pair to a SortedDictionary, returning false instead of throwing an ArgumentException if the key already exists?', 'TryAdd(key, value)', 'AddSafe(key, value)', 'Insert(key, value)', 'Append(key, value)', 'A', 'Introduced in .NET Core and .NET Standard, the TryAdd(key, value) method attempts to add the pair. If the key already exists in the binary tree, it simply returns false without overwriting the value or throwing an exception.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedDictionary', 'How can you initialize a SortedDictionary<string, int> so that the string keys are sorted in a case-insensitive manner (e.g., treating "Apple" and "apple" as the same key)?', 'new SortedDictionary<string, int>(StringComparer.OrdinalIgnoreCase);', 'new SortedDictionary<string, int>(SortOrder.CaseInsensitive);', 'new SortedDictionary<string, int>(String.CompareIgnoreCase);', 'It is impossible; strings are always sorted by their strict ASCII/Unicode values.', 'A', 'The constructor of SortedDictionary accepts an IComparer<T>. By passing a built-in comparer like StringComparer.OrdinalIgnoreCase, the internal Red-Black tree uses this logic to map, match, and sort the keys globally.');