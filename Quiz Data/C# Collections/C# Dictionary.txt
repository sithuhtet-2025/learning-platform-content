INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'Which of the following statements best describes the System.Collections.Generic.Dictionary<TKey, TValue> class in C#?', 'It is a strongly typed collection of sequentially ordered elements accessed by an integer index.', 'It is a generic collection that stores key/value pairs and provides fast lookups based on a hash table.', 'It is a thread-safe collection used strictly for asynchronous programming.', 'It is a legacy collection that stores both keys and values as generic object types.', 'B', 'Dictionary<TKey, TValue> is a generic collection that stores key/value pairs. Internally, it is implemented as a hash table, providing approaching O(1) time complexity for insertions and retrievals under normal conditions.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'What happens if you use the Add(key, value) method on a Dictionary<int, string> to insert a key that already exists in the collection?', 'The new value overwrites the existing value associated with that key silently.', 'The method returns false and leaves the existing value unchanged.', 'An ArgumentException is thrown at runtime.', 'A KeyNotFoundException is thrown at runtime.', 'C', 'The Add method strictly requires the key to be unique; if the key already exists, it throws an ArgumentException. To safely overwrite an existing value or add a new one if it doesn''t exist, use the indexer (e.g., dict[key] = value;).');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'Which is the most efficient and exception-safe way to retrieve a value from a Dictionary<string, int> when you are unsure if the key exists?', 'Use a try-catch block around int val = dict["key"];', 'Use if (dict.ContainsKey("key")) { int val = dict["key"]; }', 'Use the TryGetValue method, e.g., if (dict.TryGetValue("key", out int val)) { ... }', 'Use the GetValueOrDefault("key") method wrapped in a try-catch block.', 'C', 'TryGetValue is the most efficient approach. It attempts to find the key and assigns the value to the out parameter in a single hash lookup operation, returning true if successful or false without throwing an exception if the key is missing. Option B performs two separate dictionary lookups.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'Which of the following examples demonstrates the modern C# indexer initializer syntax for instantiating and populating a Dictionary?', 'var dict = new Dictionary<int, string> { { 1, "One" }, { 2, "Two" } };', 'var dict = new Dictionary<int, string> [ [1] = "One", [2] = "Two" ];', 'var dict = new Dictionary<int, string> { [1] = "One", [2] = "Two" };', 'var dict = new Dictionary<int, string>(1 = "One", 2 = "Two");', 'C', 'Option C uses the indexer initialization syntax introduced in C# 6.0 ([key] = value). Option A is the older collection initializer syntax, which is also valid but uses the Add method internally, whereas Option C uses the indexer, automatically handling duplicate keys during initialization by overwriting them.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'When iterating through a Dictionary<string, double> using a foreach loop, what data type does the iteration variable implicitly take?', 'DictionaryEntry', 'KeyValuePair<string, double>', 'Tuple<string, double>', 'dynamic', 'B', 'The Dictionary<TKey, TValue> class implements IEnumerable<KeyValuePair<TKey, TValue>>. Therefore, iterating over it yields elements of the struct KeyValuePair<TKey, TValue>, which exposes strongly-typed Key and Value properties.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'If you use a custom class as the TKey in a Dictionary<TKey, TValue>, what methods should you override in that custom class to ensure the dictionary functions correctly and performs efficient lookups?', 'ToString() and Clone()', 'CompareTo() and GetType()', 'GetHashCode() and Equals()', 'Dispose() and Finalize()', 'C', 'Dictionaries rely on hash tables. To look up a key, the dictionary first calls GetHashCode() on the key to find the correct bucket, and then calls Equals() to resolve potential hash collisions within that bucket. Custom key types must override both to guarantee correct equality logic.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'What happens if you attempt to insert a null key into a Dictionary<string, int> (e.g., dict.Add(null, 5);)?', 'The dictionary stores it at index 0 and assigns the value.', 'An ArgumentNullException is thrown at runtime.', 'A compilation error occurs because reference types cannot be keys.', 'The key is converted to an empty string ("") automatically.', 'B', 'A standard Dictionary<TKey, TValue> does not allow null to be used as a key. Attempting to pass null as a key to any dictionary method (like Add, ContainsKey, or the indexer) immediately throws an ArgumentNullException. However, null is a perfectly valid value if TValue is a reference type.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'Does the standard C# Dictionary<TKey, TValue> guarantee the order of its elements when enumerated?', 'Yes, it always returns elements sorted alphabetically by the Key.', 'Yes, it always returns elements strictly in the exact chronological order they were inserted.', 'No, elements are unordered and enumeration order is completely random every time.', 'No, while it may initially return items in insertion order, this behavior is undocumented, not guaranteed, and changes after items are removed and new ones are added.', 'D', 'The standard Dictionary<TKey, TValue> does not guarantee the order of elements. Removing elements leaves "holes" in the internal memory arrays that new insertions will fill, permanently altering the enumeration order. If strict ordering is required, a SortedDictionary or OrderedDictionary should be used.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Dictionary', 'If you know in advance that your Dictionary<int, string> will hold exactly 10,000 items, what is the best practice for its initialization?', 'var dict = new Dictionary<int, string>(10000);', 'var dict = new Dictionary<int, string>(); dict.Capacity = 10000;', 'var dict = new Dictionary<int, string>(); dict.EnsureCapacity(10000);', 'Do not specify a size; letting the dictionary auto-resize dynamically is always faster.', 'A', 'By passing the initial capacity directly to the constructor (e.g., new Dictionary<int, string>(10000)), you allocate the internal arrays to the correct size immediately. This avoids the severe CPU and memory allocation penalties of iterative rehashing that occur as the dictionary grows dynamically.');