INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'What is the primary architectural purpose of the `Thread.Sleep` method in C#?', 'To permanently terminate the thread.', 'To suspend the execution of the current thread for a specified amount of time.', 'To put the entire operating system into hibernation mode.', 'To pause the Garbage Collector.', 'B', '`Thread.Sleep` signals the operating system scheduler to suspend the currently executing thread for at least the specified duration in milliseconds, freeing up the CPU core to execute other waiting threads.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'While a thread is suspended due to a `Thread.Sleep` call, how many CPU cycles does it actively consume?', 'It consumes 100% of a single core in a "busy wait" loop.', 'It consumes a low, steady amount of CPU to monitor the internal timer.', 'It consumes absolutely zero CPU cycles until the operating system scheduler wakes it up.', 'It consumes CPU cycles only if other threads are idle.', 'C', 'Unlike a `while` loop spin-wait (which burns CPU cycles doing absolutely nothing), `Thread.Sleep` removes the thread from the CPU''s active ready queue entirely. The thread consumes zero CPU resources until the OS hardware timer fires and moves it back to the ready queue.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'When `Thread.Sleep` is called, what exact `ThreadState` does the executing thread transition into?', 'Stopped', 'Suspended', 'WaitSleepJoin', 'Background', 'C', 'Any operation that explicitly blocks a thread from executing (like `Sleep()`, `Join()`, or waiting to acquire a `lock`) causes the CLR to transition the thread''s internal state to `WaitSleepJoin`, indicating to the runtime that it is currently blocked and yielding execution.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'What is the specific, highly specialized behavior of calling `Thread.Sleep(0)`?', 'It throws an `ArgumentOutOfRangeException`.', 'It does absolutely nothing and execution continues instantly.', 'It forcefully terminates the thread.', 'It forces the current thread to immediately yield the remainder of its CPU time slice to any other thread of equal priority that is ready to run.', 'D', 'Passing zero to `Sleep()` acts as an explicit yield command. It tells the OS scheduler: "I am done with my current turn, let another thread of equal priority run." If no other equal-priority threads are waiting in the queue, execution continues immediately.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'What happens if you call `Thread.Sleep(Timeout.Infinite)` (or pass -1)?', 'The thread throws an `ArgumentOutOfRangeException`.', 'The thread sleeps for exactly 24 hours.', 'The thread is suspended indefinitely and will never wake up unless forcefully interrupted or aborted by another thread.', 'The thread sleeps for the maximum value of a 32-bit integer (about 24 days) and then wakes up.', 'C', 'Passing `Timeout.Infinite` (which evaluates to -1) puts the thread to sleep forever. It removes the thread from the OS scheduler''s timer queue completely. The only way it will ever wake up is if another thread calls `.Interrupt()` on it to break the block.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'If a background worker thread is stuck sleeping (`Thread.Sleep`), how can the Main thread safely force it to wake up immediately before its timer expires?', 'By calling `workerThread.Resume()`.', 'By calling `workerThread.Start()` again.', 'By calling `workerThread.Interrupt()`, which injects a `ThreadInterruptedException` into the sleeping thread.', 'It is impossible to wake a sleeping thread early; you must wait for the timer.', 'C', 'The `Interrupt()` method forcefully awakens a thread that is stuck in the `WaitSleepJoin` state. It accomplishes this by throwing a `ThreadInterruptedException` directly inside the sleeping thread, forcing it to wake up instantly and handle the exception.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'In modern C# architectural design (Task Parallel Library), why is `Thread.Sleep()` strictly considered an anti-pattern inside asynchronous (`async`) methods?', 'Because it causes memory leaks in the heap.', 'Because it synchronously blocks the physical thread, preventing it from executing other tasks, whereas `await Task.Delay()` asynchronously yields the thread back to the pool without blocking.', 'Because `Thread.Sleep` cannot accept time values greater than 1000 milliseconds.', 'Because it automatically triggers the Garbage Collector.', 'B', '`Thread.Sleep` physically blocks the actual OS thread, wasting a valuable ThreadPool resource. In an `async` method, `await Task.Delay()` should always be used. It creates a timer and immediately returns the physical thread to the pool to do other work, resuming the method when the timer fires.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Thread Sleep', 'Why is calling `Thread.Sleep(1)` NOT guaranteed to pause the thread for exactly 1 millisecond?', 'Because the C# compiler rounds all sleep times up to 10 milliseconds.', 'Because the sleep duration is inherently tied to the resolution of the underlying operating system''s system clock timer (typically around 15.6 milliseconds on Windows).', 'Because the CLR adds an artificial 5-millisecond delay to all threading operations.', 'Because it depends entirely on the speed of the CPU cache.', 'B', '`Thread.Sleep` relies on the OS scheduler and hardware timer interrupts. Standard Windows timer resolution is usually 15.6ms (64 Hz). Therefore, `Sleep(1)` will typically pause the thread for roughly 15 milliseconds, making it totally unsuitable for ultra-high-precision timing loops.');