INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'How is the generic SortedList<TKey, TValue> internally implemented in C#?', 'As a single linked list of KeyValue pairs.', 'As a binary search tree (Red-Black tree).', 'As a hash table with a linked list for insertion order.', 'As two separate arrays: one for keys and one for values.', 'D', 'SortedList<TKey, TValue> maintains two separate arrays internallyâ€”one for the keys and one for the corresponding values. It keeps the keys array sorted to allow binary search lookups.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'What is the standard time complexity for inserting a new key/value pair into a SortedList<TKey, TValue>?', 'O(1)', 'O(log n)', 'O(n)', 'O(n^2)', 'C', 'While finding the insertion point takes O(log n) using binary search, inserting the element requires physically shifting all subsequent elements in both the keys and values arrays to the right, resulting in an O(n) operation.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'Which of the following is a unique capability of SortedList<TKey, TValue> that is NOT natively supported by SortedDictionary<TKey, TValue>?', 'Retrieving elements using an integer index (e.g., list.Values[0]).', 'Sorting elements using a custom IComparer<T>.', 'Iterating over the collection using a foreach loop.', 'Guaranteeing that keys are unique.', 'A', 'Because SortedList is backed by arrays, it exposes Keys and Values properties that implement IList<T>, allowing highly efficient O(1) index-based access (e.g., retrieving the 5th sorted item directly). SortedDictionary does not support index-based access.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'When choosing between SortedList and SortedDictionary for a scenario with infrequent insertions but high volume lookups, which is generally better and why?', 'SortedDictionary, because tree traversal is faster than binary search on an array.', 'SortedList, because it uses less memory (no node objects) and provides excellent cache locality for binary searches.', 'SortedDictionary, because it automatically trims its capacity after deletions.', 'Both perform identically for lookups and memory usage.', 'B', 'SortedList is highly memory efficient and cache-friendly because it uses contiguous arrays rather than allocating individual node objects on the heap. Binary search on arrays provides very fast O(log n) lookups, making it ideal for read-heavy scenarios.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'What happens if you attempt to add a new element to a SortedList<TKey, TValue> using a key that already exists?', 'The existing value is silently overwritten.', 'The element is added, allowing duplicate keys.', 'An ArgumentException is thrown.', 'The list automatically appends an integer suffix to the key to make it unique.', 'C', 'Like most standard dictionary-style collections in C#, SortedList requires keys to be strictly unique. Calling the Add method with a duplicate key immediately throws an ArgumentException.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'What occurs internally when the internal arrays of a SortedList reach their maximum capacity during an insertion?', 'An OutOfMemoryException is thrown.', 'The list drops the oldest elements to make room for new ones.', 'The arrays are reallocated to a larger size (typically double) and the existing elements are copied over.', 'The list switches its internal implementation to a linked list.', 'C', 'When the Capacity is reached, the SortedList must allocate new, larger internal arrays and physically copy all existing keys and values into the new memory spaces. This is an O(n) operation, which is why setting an initial capacity is a best practice if the size is known.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'If you need to remove the element with the highest key value from a SortedList<int, string>, which approach is the most efficient?', 'Call list.Remove(list.Keys.Max());', 'Iterate through the list to find the max key, then call Remove().', 'Call list.RemoveAt(list.Count - 1);', 'Call list.Clear() and re-add all other elements.', 'C', 'Because the internal arrays are always sorted, the highest key is always located at the very end of the arrays. Calling RemoveAt(list.Count - 1) is an O(1) operation because it simply decrements the logical count without needing to shift any array elements.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# SortedList', 'Which interface must the `TKey` type implement for a SortedList to function, assuming no custom comparer is provided in the constructor?', 'IEnumerable<T>', 'IEquatable<T>', 'IComparable<T>', 'ICloneable', 'C', 'The SortedList requires keys to be compared to each other to maintain strict sorting within the arrays. Therefore, the key type must implement IComparable<T>, or an IComparer<T> must be explicitly provided when instantiating the list.');