INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'What is the fundamental architectural difference between a `struct` and a `class` in C# regarding memory allocation?', 'Structs are reference types stored on the heap.', 'Structs are value types typically allocated directly where they are declared (like the execution stack), whereas classes are reference types dynamically allocated on the managed heap.', 'Structs are strictly for unmanaged memory.', 'There is no difference in memory allocation.', 'B', 'The primary distinction is that a `struct` is a value type. Its payload is stored directly in line, eliminating the overhead of garbage collection and heap pointer allocation associated with reference types (`class`).');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'What is the strict object-oriented inheritance rule applied to structs in C#?', 'A struct can inherit from a single class.', 'A struct can inherit from multiple other structs.', 'Structs do not support inheritance; they are implicitly sealed and cannot inherit from any other class or struct, nor can they act as a base type.', 'Structs can only inherit from `System.Exception`.', 'C', 'Structs are designed to be lightweight. To prevent the massive memory overhead of virtual method tables (v-tables) and object headers required for polymorphism, structs are strictly sealed and completely forbid structural inheritance (though they all implicitly inherit from `System.ValueType`).');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'If you have a struct `Point p1 = new Point(5, 5);` and you assign it to a new variable `Point p2 = p1;`, what exactly happens in memory?', '`p2` becomes a pointer referencing the exact same memory location as `p1`.', 'A complete, independent bit-by-bit copy of the struct''s data payload is created in a new memory location for `p2`.', 'The compiler throws an error because structs cannot be copied.', '`p1` is destroyed and its data is moved to `p2`.', 'B', 'Because structs are value types, assigning one struct variable to another (or passing it to a method by value) triggers a full physical copy of its entire data payload. Modifying `p2` will have absolutely zero effect on the original `p1`.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'Even though structs cannot inherit from other classes or structs, can they implement interfaces?', 'No, interfaces are strictly for reference types.', 'Yes, but only interfaces defined in the `System` namespace.', 'Yes, structs can implement one or more interfaces, fulfilling polymorphism contracts.', 'Yes, but all interface methods must be implemented as `static`.', 'C', 'While structs forbid structural inheritance, they fully support contract implementation. A struct can implement interfaces (e.g., `IEquatable<T>`), allowing it to be treated polymorphically, though casting a struct to an interface causes it to be "boxed" onto the managed heap.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'Historically (and generally in modern C#), why does the CLR optimize structs by initializing their memory to zeros instead of forcing execution of a parameterless constructor for every instance?', 'Because structs cannot contain methods.', 'To guarantee that creating massive arrays of structs (e.g., `new Point[10000]`) can instantly allocate a block of memory initialized to zero without incurring the catastrophic performance penalty of executing 10,000 constructor methods.', 'Because structs do not use the `new` keyword.', 'To prevent memory leaks.', 'B', 'The CLR is engineered to rapidly zero-initialize memory for value types. Forcing custom parameterless constructors to execute for every single element during array allocation would destroy the raw performance benefits of using a struct in the first place.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'Introduced in C# 7.2, what is the architectural benefit of declaring an entire struct as a `readonly struct`?', 'It prevents the struct from ever being instantiated.', 'It forces all fields and properties to be strictly immutable, allowing the C# compiler to heavily optimize performance by safely passing the struct by reference (using `in`) without generating hidden "defensive memory copies".', 'It securely encrypts the struct in memory.', 'It hides the struct from external assemblies.', 'B', 'By marking the struct as `readonly`, you mathematically guarantee its state cannot mutate after initialization. The compiler leverages this strict guarantee to eliminate hidden defensive copies when passing the struct to methods, drastically boosting performance for larger value types.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'By default, can you assign the value `null` to a custom struct variable (e.g., `MyStruct s = null;`)?', 'Yes, all objects in C# can be null.', 'Yes, but only if it contains reference type fields like strings.', 'No, structs are value types representing physical blocks of data; they cannot mathematically be null unless explicitly wrapped in the generic `Nullable<T>` struct (e.g., `MyStruct? s = null;`).', 'No, nulls are strictly reserved for the `string` class.', 'C', 'A value type represents a fixed block of memory containing actual data (even if that data is just default zeros). A `null` represents an empty reference pointer. Since a value type is not a pointer, it cannot be null. You must use the `Nullable<T>` wrapper to support a null state.');

INSERT INTO Quizzes (LessonTitle, QuestionText, OptionA, OptionB, OptionC, OptionD, CorrectAnswer, Explanation) VALUES 
('C# Structs', 'According to Microsoft''s strict architectural design guidelines, when should a developer explicitly choose to define a `struct` instead of a `class`?', 'When the object requires complex, multi-level inheritance hierarchies.', 'When the object is very large (over 64 bytes) and contains heavy data collections.', 'When the object is small (under 16 bytes), logically represents a single cohesive value (like a Point, Guid, or Color), is immutable, and will not be boxed frequently.', 'When the object needs to manage an external SQL database connection.', 'C', 'Structs should be strictly reserved for small, lightweight, primitive-like data structures. If a struct is too large, the CPU overhead of constantly performing bit-by-bit physical memory copies during assignments and method calls will drastically outweigh the performance benefits of avoiding heap allocation.');